#Only works for symmetric laminates for now
#Reference: Example 1 page 17 Chapter 9 Lecture Slides for strain calculation
#Reference: Example page 19 Chapter 8 Lecture Slides for Primary and Principle stress plots
import numpy as np
import matplotlib.pyplot as plt
from math import cos, sin, pi

np.set_printoptions(precision=4)

#Stiffness matrix Q e-2
Q0=[[155.7*1e7,3.02*1e7,0*1e7],[3.02*1e7,12.16*1e7,0*1e7],[0*1e7,0*1e7,4.40*1e7]]
print (np.array(Q0))

#Laminate parameters
stack=[0,pi/2,pi/2,0] #Stacking sequence from top down
thickness=[0.15*1e-3,0.15*1e-3,0.15*1e-3,0.15*1e-3] #Thickness of each ply from top down
#Unit test len(stack)=len(thickness)?

#Input forces N and moments M per unit length (N/m, N)
forces=np.array([50400,1809,0]) #Nx, Ny, Nxy
moments=np.array([0,0,0]) #Mx, My, Mxy
forces.shape=[3,1]
moments.shape=[3,1]

#Configure stacking sequence and create array of ply heights about the midplane
midplane=np.sum(thickness[:])/2 #Geometric midplane
#Array element right before the geometric midplane
#This is the reason unsymmetric laminates will break the calculator
mid=int(len(thickness)/2)
        
if (len(thickness)%2==1): #Odd number of plies
    height=np.zeros(len(thickness)+2)
    stack.insert(mid+int(1),stack[mid]) #Duplicate the middle ply angle
    thickness[mid]=thickness[mid]/2 #Halve the thickness of the middle ply
    thickness.insert(mid+1,thickness[mid]) #Duplicate the middle ply thickness
    print("Odd \n",height,", ",stack,"\n")
else: #Even number of plies
    height=np.zeros(len(thickness)+1)
    print("Even \n",height,", ",stack,"\n")

for i in range(len(height)):
    height[i]=np.sum(thickness[0:i])-midplane
print("(midplane, height array) ",midplane,", ",height,'\n')

#Transformation matrix T1 inverse (primary strain --> principal strain)
#Transformation T2 (principal stress --> primary stress)

#Function returns transformed stiffness matrix Qbar
def transform_Q(Q0,ply_angle):
    m=cos(ply_angle)
    n=sin(ply_angle)
    T1=[[m**2,n**2,2*m*n],[n**2,m**2,-2*m*n],[-m*n,m*n,m**2-n**2]]
    T2=[[m**2,n**2,m*n],[n**2,m**2,-m*n],[-2*m*n,2*m*n,m**2-n**2]]
    T1_inv=np.linalg.inv(T1)
    Qbar=np.linalg.multi_dot([T1_inv,Q0,T2])
   
    return Qbar

#Function returns the stress in primary material directions as a column vector
def transform_T1(principalStress,ply_angle):
    m=cos(ply_angle)
    n=sin(ply_angle)
    T1=[[m**2,n**2,2*m*n],[n**2,m**2,-2*m*n],[-m*n,m*n,m**2-n**2]]
    primaryStress=np.dot(T1,principalStress)
    
    return primaryStress

#Function returns the strain in primary material directions as a column vector
def transform_T2(principalStrain,ply_angle):
    m=cos(ply_angle)
    n=sin(ply_angle)
    T2=[[m**2,n**2,m*n],[n**2,m**2,-m*n],[-2*m*n,2*m*n,m**2-n**2]]
    primaryStrain=np.dot(T2,principalStrain)
    
    return primaryStrain

#Calculate A, B, D matrices by integrating transformed stiffness matrix over all plies based on laminate 
#constitutive equations
#Units for A, B, D matrices respectively are hN/m, hN, hNm

A=np.zeros([3,3])
B=np.zeros([3,3])
B_inv=B
D=np.zeros([3,3])

for i in range(len(Q0)):
    for j in range(len(Q0[0])):
        for k in range(len(stack)):
            Qbar=transform_Q(Q0,stack[k])
            ply_kA=height[k+1]-height[k]
            ply_kB=(height[k+1]**2-height[k]**2)/2
            ply_kD=(height[k+1]**3-height[k]**3)/3
            A[i,j]+=ply_kA*Qbar[i,j]
            B[i,j]+=ply_kB*Qbar[i,j]
            D[i,j]+=ply_kD*Qbar[i,j]

print("\n","A \n",A,"\n B \n",B,"\n D \n",D,"\n")            
A_inv=np.linalg.inv(A)

#Set ABD matrix, and force column vectors
#I think I made a mistake here. The extension-twisting coupling matrix should be B transpose
ABD=np.concatenate((np.concatenate((A,B),axis=0),np.concatenate((B,D),axis=0)),axis=1)
print ("\n ABD stiffness matrix in hectanewton/meter, hectanewton, and hectanewton meter respectively: \n",ABD,"\n")
force_moment=np.concatenate((forces,moments))

#Calculate principal laminate strains and radii of curvature at midplane
midstrain=np.dot(np.linalg.inv(ABD),force_moment)
print ("\n Strains (ex, ey, exy) and radii of curvature (kx, ky, kxy): \n",midstrain)

#Assign variables for principal strains and stresses in each ply k
#Calculate principal and primary strains and stresses in each ply k
#Strain varies linearly
estrain_glob=midstrain[:3]
kstrain_glob=midstrain[3:6]
plystrain_glob=np.zeros(shape=(3,2*len(height)-2))
plystress_glob=np.zeros(shape=(3,2*len(height)-2))
plystrain_loc=np.zeros(shape=(3,2*len(height)-2))
plystress_loc=np.zeros(shape=(3,2*len(height)-2))
#estrain_glob.shape=[3,1]
#kstrain_glob.shape=[3,1]

#Calculate 2 values of strain and stress for every height element, excluding 
#the first and last heights which only result in 1 value of strain and stress because they're on the surface
#There's an opportunity to remove the inner loop but when I try to make height a column vector the dimensions are mismatched
for k in range(len(height)-1):
    for i in range(3):
        plystrain_glob[i,2*k]=estrain_glob[i]+height[k]*kstrain_glob[i]
        plystrain_glob[i,2*k+1]=estrain_glob[i]+height[k+1]*kstrain_glob[i]
    Qbar=transform_Q(Q0,stack[k])
    plystress_glob[:,2*k]=np.dot(Qbar,plystrain_glob[:,2*k])
    Qbar=transform_Q(Q0,stack[k])
    plystress_glob[:,2*k+1]=np.dot(Qbar,plystrain_glob[:,2*k+1])

print("\n Principal Strain for each ply boundary: \n",plystrain_glob,"\n")
print("\n Principal Stress for each ply boundary: \n",plystress_glob,"\n")

#Sanity check to ensure array dimensions are correct
#print ("plystrain_glob shape",plystrain_glob.shape)
#print ("height shape",height.shape)
#print("estrain_glob shape",estrain_glob.shape)
#print("kstrain_glob shape",kstrain_glob.shape)

for k in range(len(height)-1):
    plystrain_loc[:,2*k]=transform_T1(plystrain_glob[:,2*k],stack[k])
    plystrain_loc[:,2*k+1]=transform_T1(plystrain_glob[:,2*k+1],stack[k])
    plystress_loc[:,2*k]=transform_T1(plystress_glob[:,2*k],stack[k])
    plystress_loc[:,2*k+1]=transform_T1(plystress_glob[:,2*k+1],stack[k])
print("\n Primary Strain for each ply boundary: \n",plystrain_loc,"\n")
print("\n Primary Stress for each ply boundary: \n",plystress_loc,"\n")
    
plot_height=np.zeros(2*len(height)-2) #x values for plotting purposes mwahahahah >:]  
for k in range(len(height)-1):
    plot_height[2*k]=height[k]
    plot_height[2*k+1]=height[k+1]
